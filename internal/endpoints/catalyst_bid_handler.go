package endpoints

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/thenexusengine/tne_springwire/internal/device"
	"github.com/thenexusengine/tne_springwire/internal/exchange"
	"github.com/thenexusengine/tne_springwire/internal/geo"
	"github.com/thenexusengine/tne_springwire/internal/openrtb"
	"github.com/thenexusengine/tne_springwire/internal/storage"
	"github.com/thenexusengine/tne_springwire/internal/usersync"
	"github.com/thenexusengine/tne_springwire/pkg/logger"
)

// BidderMapping represents the full bidder parameter mapping configuration
type BidderMapping struct {
	Publisher struct {
		PublisherID    string   `json:"publisherId"`
		Domain         string   `json:"domain"`
		DefaultBidders []string `json:"defaultBidders"`
	} `json:"publisher"`
	AdUnits map[string]AdUnitConfig `json:"adUnits"`
}

// AdUnitConfig contains bidder-specific parameters for an ad unit
type AdUnitConfig struct {
	Rubicon    *RubiconParams    `json:"rubicon,omitempty"`
	Kargo      *KargoParams      `json:"kargo,omitempty"`
	Sovrn      *SovrnParams      `json:"sovrn,omitempty"`
	Pubmatic   *PubmaticParams   `json:"pubmatic,omitempty"`
	Triplelift *TripleliftParams `json:"triplelift,omitempty"`
}

// RubiconParams are Rubicon/Magnite adapter parameters
type RubiconParams struct {
	AccountID        int  `json:"accountId"`
	SiteID           int  `json:"siteId"`
	ZoneID           int  `json:"zoneId"`
	BidOnMultiFormat bool `json:"bidonmultiformat"`
}

// KargoParams are Kargo adapter parameters
type KargoParams struct {
	PlacementID string `json:"placementId"`
}

// SovrnParams are Sovrn adapter parameters
type SovrnParams struct {
	TagID string `json:"tagid"` // Must be string per Prebid Server spec
}

// PubmaticParams are Pubmatic adapter parameters
type PubmaticParams struct {
	PublisherID string `json:"publisherId"` // Must be string per Prebid Server spec
	AdSlot      string `json:"adSlot"`      // Must be string per Prebid Server spec
}

// TripleliftParams are Triplelift adapter parameters
type TripleliftParams struct {
	InventoryCode string `json:"inventoryCode"`
}

// CatalystBidHandler handles MAI Publisher-compatible bid requests
type CatalystBidHandler struct {
	exchange       *exchange.Exchange
	mapping        *BidderMapping      // Legacy: static mapping file (fallback)
	publisherStore *storage.PublisherStore // Dynamic hierarchical config from database
}

// LoadBidderMapping loads bidder parameter mapping from JSON file
func LoadBidderMapping(path string) (*BidderMapping, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read mapping file: %w", err)
	}

	var mapping BidderMapping
	if err := json.Unmarshal(data, &mapping); err != nil {
		return nil, fmt.Errorf("failed to parse mapping JSON: %w", err)
	}

	logger.Log.Info().
		Int("ad_units", len(mapping.AdUnits)).
		Str("publisher", mapping.Publisher.PublisherID).
		Msg("Loaded bidder mapping")

	return &mapping, nil
}

// NewCatalystBidHandler creates a new Catalyst bid handler
func NewCatalystBidHandler(ex *exchange.Exchange, mapping *BidderMapping, publisherStore *storage.PublisherStore) *CatalystBidHandler {
	return &CatalystBidHandler{
		exchange:       ex,
		mapping:        mapping,
		publisherStore: publisherStore,
	}
}

// MAIBidRequest represents the MAI Publisher bid request format
type MAIBidRequest struct {
	AccountID string       `json:"accountId"`
	Timeout   int          `json:"timeout"` // Client-side timeout in ms
	Slots     []MAISlot    `json:"slots"`
	Page      *MAIPage     `json:"page,omitempty"`
	User      *MAIUser     `json:"user,omitempty"`
	Device    *MAIDevice   `json:"device,omitempty"`
}

// MAISlot represents an ad slot
type MAISlot struct {
	DivID          string      `json:"divId"`
	Sizes          [][]int     `json:"sizes"`
	AdUnitPath     string      `json:"adUnitPath,omitempty"`
	Position       string      `json:"position,omitempty"`
	EnabledBidders []string    `json:"enabled_bidders,omitempty"`
}

// MAIPage represents page context
type MAIPage struct {
	URL        string   `json:"url,omitempty"`
	Domain     string   `json:"domain,omitempty"`
	Keywords   []string `json:"keywords,omitempty"`
	Categories []string `json:"categories,omitempty"`
}

// MAIUser represents user/privacy info
type MAIUser struct {
	FPID           string                   `json:"fpid,omitempty"`           // First-party identifier
	ConsentGiven   bool                     `json:"consentGiven,omitempty"`
	ConsentString  string                   `json:"consentString,omitempty"`  // TCFv2 consent string
	GDPRApplies    bool                     `json:"gdprApplies,omitempty"`
	USPConsent     string                   `json:"uspConsent,omitempty"`
	UserIds        map[string]string        `json:"userIds,omitempty"`        // Bidder-specific user IDs from cookie sync
	Data           []map[string]interface{} `json:"data,omitempty"`           // ORTB2 user data segments
	Ext            map[string]interface{}   `json:"ext,omitempty"`            // Additional user extensions
}

// MAIDevice represents device info
type MAIDevice struct {
	Width      int      `json:"width,omitempty"`
	Height     int      `json:"height,omitempty"`
	DeviceType string   `json:"deviceType,omitempty"`
	UserAgent  string   `json:"userAgent,omitempty"`
	Geo        *MAIGeo  `json:"geo,omitempty"` // Client-side geolocation (optional)
}

// MAIGeo represents client-side geolocation data
type MAIGeo struct {
	Lat      float64 `json:"lat,omitempty"`      // Latitude from GPS/browser
	Lon      float64 `json:"lon,omitempty"`      // Longitude from GPS/browser
	Accuracy int     `json:"accuracy,omitempty"` // Accuracy in meters
}

// MAIBidResponse represents the MAI Publisher bid response format
type MAIBidResponse struct {
	Bids         []MAIBid `json:"bids"`
	ResponseTime int      `json:"responseTime"` // In milliseconds
}

// MAIBid represents a single bid
type MAIBid struct {
	DivID      string      `json:"divId"`
	CPM        float64     `json:"cpm"`
	Currency   string      `json:"currency"`
	Width      int         `json:"width"`
	Height     int         `json:"height"`
	AdID       string      `json:"adId"`
	CreativeID string      `json:"creativeId"`
	DealID     string      `json:"dealId,omitempty"`
	Meta       *MAIBidMeta `json:"meta,omitempty"`
}

// MAIBidMeta represents bid metadata
type MAIBidMeta struct {
	AdvertiserDomains []string `json:"advertiserDomains,omitempty"`
	NetworkID         string   `json:"networkId,omitempty"`
	NetworkName       string   `json:"networkName,omitempty"`
}

// HandleBidRequest handles POST /v1/bid requests
func (h *CatalystBidHandler) HandleBidRequest(w http.ResponseWriter, r *http.Request) {
	log := logger.Log
	startTime := time.Now()

	// CORS is handled by middleware - removed hardcoded wildcard

	// Only accept POST
	if r.Method != "POST" {
		log.Error().
			Str("method", r.Method).
			Str("path", r.URL.Path).
			Msg("Method not allowed - expected POST")
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Parse MAI bid request
	var maiBidReq MAIBidRequest

	// Close body when done
	defer r.Body.Close()

	// Limit request body size to prevent DoS attacks (1MB limit)
	const maxRequestBodySize = 1024 * 1024 // 1MB
	bodyBytes, err := io.ReadAll(io.LimitReader(r.Body, maxRequestBodySize))
	if err != nil {
		log.Error().
			Err(err).
			Str("remote_addr", r.RemoteAddr).
			Str("user_agent", r.Header.Get("User-Agent")).
			Msg("Failed to read MAI bid request body")
		h.writeErrorResponse(w, "Invalid request format", http.StatusBadRequest)
		return
	}

	// DEBUG: Full request dump if enabled
	debugDumpRequests := os.Getenv("DEBUG_DUMP_REQUESTS") == "true"
	if debugDumpRequests {
		log.Debug().
			Str("method", r.Method).
			Str("path", r.URL.Path).
			Str("remote_addr", r.RemoteAddr).
			Str("user_agent", r.Header.Get("User-Agent")).
			Str("content_type", r.Header.Get("Content-Type")).
			Str("request_body", string(bodyBytes)).
			Msg("üîç DEBUG_DUMP_REQUESTS: Full incoming request")
	} else {
		// Log preview for normal debug mode
		requestPreview := string(bodyBytes)
		if len(requestPreview) > 2000 {
			requestPreview = requestPreview[:2000] + "..."
		}
		log.Debug().Str("request_body_preview", requestPreview).Msg("Received MAI bid request")
	}

	if err := json.Unmarshal(bodyBytes, &maiBidReq); err != nil {
		log.Error().
			Err(err).
			Str("request_body", string(bodyBytes)).
			Msg("Failed to parse MAI bid request - invalid JSON")
		h.writeErrorResponse(w, "Invalid request format", http.StatusBadRequest)
		return
	}

	// Validate request
	if err := h.validateMAIBidRequest(&maiBidReq); err != nil {
		log.Error().
			Err(err).
			Str("account_id", maiBidReq.AccountID).
			Int("slots_count", len(maiBidReq.Slots)).
			Interface("request", maiBidReq).
			Msg("‚ùå Invalid MAI bid request - validation failed")
		h.writeErrorResponse(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Convert to OpenRTB
	ortbReq, impToSlot, err := h.convertToOpenRTB(r, &maiBidReq)
	if err != nil {
		log.Error().
			Err(err).
			Str("account_id", maiBidReq.AccountID).
			Int("slots_count", len(maiBidReq.Slots)).
			Msg("‚ùå Failed to convert to OpenRTB")
		h.writeErrorResponse(w, "Internal error", http.StatusInternalServerError)
		return
	}

	// Run auction with 2500ms timeout (MAI Publisher requirement)
	ctx, cancel := context.WithTimeout(r.Context(), 2500*time.Millisecond)
	defer cancel()

	auctionReq := &exchange.AuctionRequest{
		BidRequest: ortbReq,
		Timeout:    2500 * time.Millisecond,
	}

	auctionResp, err := h.exchange.RunAuction(ctx, auctionReq)
	if err != nil {
		log.Error().
			Err(err).
			Str("account_id", maiBidReq.AccountID).
			Int("slots", len(maiBidReq.Slots)).
			Int("timeout_ms", int(time.Since(startTime).Milliseconds())).
			Str("error_type", fmt.Sprintf("%T", err)).
			Msg("‚ùå Auction failed - returning empty bids")
		// Return empty bids on error (MAI Publisher requirement)
		h.writeMAIResponse(w, &MAIBidResponse{
			Bids:         []MAIBid{},
			ResponseTime: int(time.Since(startTime).Milliseconds()),
		})
		return
	}

	// Convert OpenRTB response to MAI format
	maiResp := h.convertToMAIResponse(auctionResp, impToSlot)
	maiResp.ResponseTime = int(time.Since(startTime).Milliseconds())

	// DEBUG: Full response dump if enabled
	debugDumpResponses := os.Getenv("DEBUG_DUMP_RESPONSES") == "true"
	if debugDumpResponses {
		if respJSON, err := json.Marshal(maiResp); err == nil {
			log.Debug().
				Str("response_body", string(respJSON)).
				Int("bids", len(maiResp.Bids)).
				Int("response_time_ms", maiResp.ResponseTime).
				Msg("üîç DEBUG_DUMP_RESPONSES: Full outgoing response")
		}
	} else {
		// Normal debug logging
		log.Debug().
			Int("bids", len(maiResp.Bids)).
			Int("response_time_ms", maiResp.ResponseTime).
			Msg("Catalyst response ready")
	}

	// Write response
	h.writeMAIResponse(w, maiResp)

	log.Info().
		Str("account_id", maiBidReq.AccountID).
		Int("slots", len(maiBidReq.Slots)).
		Int("bids", len(maiResp.Bids)).
		Int("response_time_ms", maiResp.ResponseTime).
		Msg("‚úì Catalyst bid request completed")
}

// validateMAIBidRequest validates the MAI bid request
func (h *CatalystBidHandler) validateMAIBidRequest(req *MAIBidRequest) error {
	if req.AccountID == "" {
		return fmt.Errorf("accountId is required")
	}
	if len(req.Slots) == 0 {
		return fmt.Errorf("at least one slot is required")
	}
	for i, slot := range req.Slots {
		if slot.DivID == "" {
			return fmt.Errorf("slot[%d].divId is required", i)
		}
		if len(slot.Sizes) == 0 {
			return fmt.Errorf("slot[%d].sizes is required", i)
		}
		for j, size := range slot.Sizes {
			if len(size) != 2 || size[0] <= 0 || size[1] <= 0 {
				return fmt.Errorf("slot[%d].sizes[%d] must be [width, height] with positive values", i, j)
			}
		}
	}
	return nil
}

// convertToOpenRTB converts MAI bid request to OpenRTB format
func (h *CatalystBidHandler) convertToOpenRTB(r *http.Request, maiBid *MAIBidRequest) (*openrtb.BidRequest, map[string]string, error) {
	// Generate request ID
	requestID := fmt.Sprintf("catalyst-%d", time.Now().UnixNano())

	// Build impressions and track mapping (impID -> divID)
	imps := make([]openrtb.Imp, 0, len(maiBid.Slots))
	impToSlot := make(map[string]string) // Maps impression ID to slot divID

	for i, slot := range maiBid.Slots {
		impID := fmt.Sprintf("%d", i+1)
		impToSlot[impID] = slot.DivID

		// Convert sizes to format array
		formats := make([]openrtb.Format, len(slot.Sizes))
		for j, size := range slot.Sizes {
			formats[j] = openrtb.Format{
				W: size[0],
				H: size[1],
			}
		}

		// We'll set TagID after resolving adUnitPath below
		secureFlag := 1 // Assume HTTPS (OpenRTB 2.6 requirement)
		imp := openrtb.Imp{
			ID:     impID,
			Secure: &secureFlag,
			Banner: &openrtb.Banner{
				W:      slot.Sizes[0][0], // Use first size as primary
				H:      slot.Sizes[0][1],
				Format: formats,
			},
		}

	// Look up bidder parameters using hierarchical config (DB first, then mapping file fallback)
	// Always try to lookup bidder config, with appropriate fallbacks
	impExt := make(map[string]interface{})

	if maiBid.AccountID == "" {
		logger.Log.Warn().Msg("Missing accountId - cannot lookup bidder config")
	} else {
		// Extract domain from page context
		domain := ""
		if maiBid.Page != nil && maiBid.Page.Domain != "" {
			domain = maiBid.Page.Domain
		}

		// If adUnitPath is missing, try to resolve it from divId mapping
		adUnitPath := slot.AdUnitPath
		if adUnitPath == "" && h.publisherStore != nil {
			resolvedPath, err := h.publisherStore.GetAdUnitPathFromDivID(r.Context(), maiBid.AccountID, domain, slot.DivID)
			if err == nil && resolvedPath != "" {
				adUnitPath = resolvedPath
				logger.Log.Info().
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("div_id", slot.DivID).
					Str("resolved_path", adUnitPath).
					Msg("‚úì Resolved adUnitPath from divId mapping")
			} else {
				logger.Log.Warn().
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("div_id", slot.DivID).
					Msg("‚ö†Ô∏è  Missing adUnitPath and no divId mapping found - falling back to publisher-level config only")
			}
		}

		// Set TagID with resolved adUnitPath
		imp.TagID = adUnitPath

		// List of bidders to look up
		bidders := []string{"rubicon", "kargo", "sovrn", "pubmatic", "triplelift"}

		// Detect device type from User-Agent for device-specific bidder configs
		deviceType := "desktop" // Default to desktop
		if maiBid.Device != nil && maiBid.Device.UserAgent != "" {
			deviceType = detectDeviceType(maiBid.Device.UserAgent)
		}

		// Build slot pattern for database lookup (e.g., "totalprosports.com/billboard")
		slotPattern := ""
		if domain != "" && slot.DivID != "" {
			slotPattern = fmt.Sprintf("%s/%s", domain, slot.DivID)
		}

		// Query new normalized schema: accounts ‚Üí publishers ‚Üí ad_slots ‚Üí slot_bidder_configs
		var allConfigs map[string]map[string]interface{}
		var err error
		if h.publisherStore != nil && slotPattern != "" {
			allConfigs, err = h.publisherStore.GetSlotBidderConfigs(
				r.Context(),
				maiBid.AccountID, // CATALYST internal account ID (e.g., '12345')
				domain,           // Publisher domain (e.g., 'totalprosports.com')
				slotPattern,      // Ad slot pattern (e.g., 'totalprosports.com/billboard')
				deviceType,       // Device type ('desktop' or 'mobile')
			)
			if err != nil {
				logger.Log.Error().
					Err(err).
					Str("account_id", maiBid.AccountID).
					Str("domain", domain).
					Str("slot_pattern", slotPattern).
					Str("device_type", deviceType).
					Str("error_type", fmt.Sprintf("%T", err)).
					Str("error_msg", err.Error()).
					Msg("‚ùå Database error looking up slot bidder configs")
				allConfigs = make(map[string]map[string]interface{})
			} else {
				logger.Log.Info().
					Str("slot_pattern", slotPattern).
					Str("device_type", deviceType).
					Strs("bidder_names", getConfiguredBidders(allConfigs)).
					Int("bidders_configured", len(allConfigs)).
					Str("account_id", maiBid.AccountID).
					Str("domain", domain).
					Interface("full_config", allConfigs).
					Msg("‚úì Loaded bidder configs from normalized schema (account ‚Üí publisher ‚Üí slot)")
			}
		} else {
			// Fallback: Try legacy hierarchical lookup if slot pattern unavailable
			if h.publisherStore != nil && adUnitPath != "" {
				allConfigs, err = h.publisherStore.GetAllBidderConfigsHierarchical(
					r.Context(),
					maiBid.AccountID,
					domain,
					adUnitPath,
					bidders,
				)
				if err != nil {
					logger.Log.Warn().
						Err(err).
						Str("account_id", maiBid.AccountID).
						Msg("‚ö†Ô∏è  Legacy hierarchical config lookup failed - using fallback")
					allConfigs = make(map[string]map[string]interface{})
				}
			} else {
				logger.Log.Warn().
					Str("account_id", maiBid.AccountID).
					Str("domain", domain).
					Str("div_id", slot.DivID).
					Msg("‚ö†Ô∏è  Missing slot pattern - cannot query bidder configs")
				allConfigs = make(map[string]map[string]interface{})
			}
		}

		// Now populate impExt with configs
		for _, bidderCode := range bidders {
			params := allConfigs[bidderCode]

			// If no DB config found, fall back to mapping file (only if we have adUnitPath)
			if params == nil && h.mapping != nil && adUnitPath != "" {
				if adUnitConfig, ok := h.mapping.AdUnits[adUnitPath]; ok {
					params = h.extractBidderParamsFromMapping(bidderCode, &adUnitConfig)
				}
			}

			// Add params to impExt if found
			if params != nil && len(params) > 0 {
				impExt[bidderCode] = params
			} else {
				logger.Log.Warn().
					Str("bidder", bidderCode).
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("ad_unit", adUnitPath).
					Msg("‚ö†Ô∏è  No configuration found for bidder")
			}
		}

		// Marshal and attach to impression
		if len(impExt) > 0 {
			extJSON, err := json.Marshal(impExt)
			if err == nil {
				imp.Ext = extJSON
				logger.Log.Info().
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("ad_unit", adUnitPath).
					Int("bidders_configured", len(impExt)).
					Interface("bidder_names", getBidderNames(impExt)).
					Interface("full_config", impExt).
					Msg("‚úì Injected bidder parameters using hierarchical config")
			} else {
				logger.Log.Error().
					Err(err).
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("ad_unit", adUnitPath).
					Interface("impExt", impExt).
					Msg("‚ùå Failed to marshal bidder parameters")
			}
		} else {
			logger.Log.Error().
				Str("publisher", maiBid.AccountID).
				Str("domain", domain).
				Str("ad_unit", adUnitPath).
				Str("div_id", slot.DivID).
				Msg("‚ùå ZERO bidder configuration found - no bids will be returned for this slot!")
		}
	}

		imps = append(imps, imp)
	}

	// Build site
	// NOTE: We intentionally leave site.id EMPTY to prevent leaking CATALYST's
	// internal accountId ('12345') to SSPs. Each adapter sets SSP-specific IDs.
	site := &openrtb.Site{}

	if maiBid.Page != nil {
		site.Domain = maiBid.Page.Domain
		if maiBid.Page.URL != "" {
			site.Page = maiBid.Page.URL
		}
		if maiBid.Page.Domain == "" && maiBid.Page.URL != "" {
			// Extract domain from URL if not provided
			site.Domain = extractDomain(maiBid.Page.URL)
		}
		if len(maiBid.Page.Keywords) > 0 {
			site.Keywords = strings.Join(maiBid.Page.Keywords, ",")
		}
		if len(maiBid.Page.Categories) > 0 {
			site.Cat = maiBid.Page.Categories
		}
	}

	// NOTE: We intentionally leave publisher.id EMPTY to prevent leaking CATALYST's
	// internal accountId. Adapters set SSP-specific publisher IDs from bidder configs.
	site.Publisher = &openrtb.Publisher{}

	// Get publisher name from database for brand safety
	if h.publisherStore != nil {
		if pub, err := h.publisherStore.GetByPublisherID(r.Context(), maiBid.AccountID); err == nil && pub != nil {
			if publisher, ok := pub.(*storage.Publisher); ok && publisher.Name != "" {
				site.Publisher.Name = publisher.Name
			}
		}
	}

	// Set publisher domain from site domain
	if site.Domain != "" {
		site.Publisher.Domain = site.Domain
	}

	// Build device
	deviceObj := &openrtb.Device{
		UA: r.Header.Get("User-Agent"),
		IP: getClientIP(r),
	}

	if maiBid.Device != nil {
		if maiBid.Device.UserAgent != "" {
			deviceObj.UA = maiBid.Device.UserAgent
		}
		if maiBid.Device.Width > 0 && maiBid.Device.Height > 0 {
			deviceObj.W = maiBid.Device.Width
			deviceObj.H = maiBid.Device.Height
		}
		// Map device type to OpenRTB device type
		switch strings.ToLower(maiBid.Device.DeviceType) {
		case "mobile", "phone":
			deviceObj.DeviceType = 1 // Mobile/Tablet
		case "tablet":
			deviceObj.DeviceType = 5 // Tablet
		case "desktop", "pc":
			deviceObj.DeviceType = 2 // Personal Computer
		case "tv", "ctv", "connected_tv":
			deviceObj.DeviceType = 3 // Connected TV
		}
	}

	// Parse User-Agent to extract device details (OpenRTB 2.6 enhancement)
	if deviceObj.UA != "" {
		if deviceInfo := device.ParseUserAgent(deviceObj.UA); deviceInfo != nil {
			// Set device make, model, os, osv from parsed UA
			deviceObj.Make = deviceInfo.Make
			deviceObj.Model = deviceInfo.Model
			deviceObj.OS = deviceInfo.OS
			deviceObj.OSV = deviceInfo.OSV

			// Override device type from UA parser if not already set from client
			if deviceObj.DeviceType == 0 {
				deviceObj.DeviceType = deviceInfo.DeviceType
			}

			logger.Log.Debug().
				Str("make", deviceObj.Make).
				Str("model", deviceObj.Model).
				Str("os", deviceObj.OS).
				Str("osv", deviceObj.OSV).
				Int("device_type", deviceObj.DeviceType).
				Msg("Parsed device details from User-Agent")
		}
	}

	// Add geolocation data (OpenRTB 2.6 critical enhancement - 15-30% CPM lift)
	// Priority: Client-side geo (GPS/browser) > IP-based geo
	if maiBid.Device != nil && maiBid.Device.Geo != nil && maiBid.Device.Geo.Lat != 0 && maiBid.Device.Geo.Lon != 0 {
		// Client-side geolocation available (most accurate)
		deviceObj.Geo = &openrtb.Geo{
			Lat:  maiBid.Device.Geo.Lat,
			Lon:  maiBid.Device.Geo.Lon,
			Type: 1, // GPS/Location Services
		}

		// Try to reverse geocode for country/region/city using IP geo service
		// This enriches client-side lat/lon with administrative region data
		if deviceObj.IP != "" {
			geoService, err := geo.GetDefaultService()
			if err == nil && geoService != nil {
				if geoInfo := geoService.LookupSafe(deviceObj.IP); geoInfo != nil {
					deviceObj.Geo.Country = geoInfo.Country
					deviceObj.Geo.Region = geoInfo.Region
					deviceObj.Geo.City = geoInfo.City
					deviceObj.Geo.Metro = geoInfo.Metro
					deviceObj.Geo.ZIP = geoInfo.Zip
				}
			}
		}

		logger.Log.Info().
			Float64("lat", deviceObj.Geo.Lat).
			Float64("lon", deviceObj.Geo.Lon).
			Str("country", deviceObj.Geo.Country).
			Int("accuracy", maiBid.Device.Geo.Accuracy).
			Msg("Using client-side geolocation (GPS/browser)")
	} else if deviceObj.IP != "" {
		// Fallback to IP-based geolocation
		geoService, err := geo.GetDefaultService()
		if err == nil && geoService != nil {
			// Perform IP geolocation lookup
			if geoInfo := geoService.LookupSafe(deviceObj.IP); geoInfo != nil {
				deviceObj.Geo = &openrtb.Geo{
					Country: geoInfo.Country,
					Region:  geoInfo.Region,
					City:    geoInfo.City,
					Metro:   geoInfo.Metro,
					ZIP:     geoInfo.Zip,
					Lat:     geoInfo.Lat,
					Lon:     geoInfo.Lon,
					Type:    2, // IP-based geolocation
				}

				logger.Log.Info().
					Str("ip", deviceObj.IP).
					Str("country", geoInfo.Country).
					Str("region", geoInfo.Region).
					Str("city", geoInfo.City).
					Float64("lat", geoInfo.Lat).
					Float64("lon", geoInfo.Lon).
					Msg("Added IP-based geolocation to device")
			} else {
				logger.Log.Debug().
					Str("ip", deviceObj.IP).
					Msg("IP geolocation lookup returned no results")
			}
		} else {
			logger.Log.Debug().
				Msg("GeoIP service not available - skipping geolocation (set GEOIP2_DB_PATH env var)")
		}
	}

	// Build user object with IDs from request body AND cookies
	var user *openrtb.User
	var regs *openrtb.Regs

	// Collect user IDs from all sources
	userIDs := make(map[string]string)

	// 1. From request body (SDK sends these)
	if maiBid.User != nil && len(maiBid.User.UserIds) > 0 {
		for bidder, uid := range maiBid.User.UserIds {
			userIDs[bidder] = uid
		}
	}

	// 2. From HTTP cookie as fallback (server-side cookie sync)
	cookieSync := usersync.ParseCookie(r)
	bidders := []string{"rubicon", "kargo", "sovrn", "pubmatic", "triplelift", "appnexus"}
	for _, bidder := range bidders {
		if uid := cookieSync.GetUID(bidder); uid != "" {
			if _, exists := userIDs[bidder]; !exists {
				userIDs[bidder] = uid
			}
		}
	}

	// Create user object if we have IDs or consent data
	if len(userIDs) > 0 || maiBid.User != nil {
		user = &openrtb.User{}

		// Set FPID as OpenRTB user.id (first-party identifier)
		if maiBid.User != nil && maiBid.User.FPID != "" {
			user.ID = maiBid.User.FPID
			logger.Log.Debug().
				Str("fpid", maiBid.User.FPID).
				Msg("Including FPID in bid request as user.id")
		}

		// MODERN: Store all bidder IDs in user.ext.eids (OpenRTB 2.6+ standard)
		// This provides transparency about ID sources and supports multiple ID types
		if len(userIDs) > 0 {
			eids := make([]map[string]interface{}, 0, len(userIDs))

			// Map bidder codes to proper source domains
			sourceDomains := map[string]string{
				"rubicon":     "rubiconproject.com",
				"kargo":       "kargo.com",
				"sovrn":       "lijit.com",
				"pubmatic":    "pubmatic.com",
				"triplelift":  "3lift.com",
				"appnexus":    "adnxs.com",
			}

			for bidder, uid := range userIDs {
				source := sourceDomains[bidder]
				if source == "" {
					source = bidder + ".com" // Fallback
				}

				eids = append(eids, map[string]interface{}{
					"source": source,
					"uids": []map[string]interface{}{
						{
							"id":    uid,
							"atype": 1, // Browser cookie-based ID
						},
					},
				})
			}

			// Build user.ext with eids and consent
			userExt := map[string]interface{}{
				"eids": eids,
			}

			// Add consent hash if available (GDPR transparency)
			if maiBid.User != nil && maiBid.User.ConsentGiven {
				userExt["consent"] = "1"
			}

			extJSON, _ := json.Marshal(userExt)
			user.Ext = extJSON

			logger.Log.Info().
				Str("fpid", user.ID).
				Int("user_ids", len(userIDs)).
				Strs("bidders", getBidderKeys(userIDs)).
				Msg("Populated user IDs from cookie sync")
		}

		// Set TCF consent string (OpenRTB 2.5+ compliance)
		if maiBid.User != nil {
			// Use actual TCF string from SDK if available
			if maiBid.User.ConsentString != "" {
				user.Consent = maiBid.User.ConsentString
				previewLen := min(20, len(maiBid.User.ConsentString))
				logger.Log.Debug().
					Str("consent_string_preview", maiBid.User.ConsentString[:previewLen]).
					Msg("Using TCFv2 consent string from SDK")
			} else if maiBid.User.ConsentGiven {
				// Fallback: If no TCF string but consent was given
				logger.Log.Warn().
					Str("account_id", maiBid.AccountID).
					Msg("GDPR consent given but no TCF string provided - bidders may reject")
				user.Consent = "1"  // Non-compliant fallback
			} else {
				user.Consent = "0"  // No consent
			}

			// Format user.data segments for first-party data targeting (OpenRTB 2.6)
			if len(maiBid.User.Data) > 0 {
				user.Data = make([]openrtb.Data, 0, len(maiBid.User.Data))
				for _, segment := range maiBid.User.Data {
					data := openrtb.Data{}

					// Extract name if present
					if name, ok := segment["name"].(string); ok {
						data.Name = name
					}

					// Extract ID if present
					if id, ok := segment["id"].(string); ok {
						data.ID = id
					}

					// Extract segments if present
					if segs, ok := segment["segment"].([]interface{}); ok {
						data.Segment = make([]openrtb.Segment, 0, len(segs))
						for _, seg := range segs {
							if segMap, ok := seg.(map[string]interface{}); ok {
								segment := openrtb.Segment{}
								if id, ok := segMap["id"].(string); ok {
									segment.ID = id
								}
								if name, ok := segMap["name"].(string); ok {
									segment.Name = name
								}
								if value, ok := segMap["value"].(string); ok {
									segment.Value = value
								}
								data.Segment = append(data.Segment, segment)
							}
						}
					}

					user.Data = append(user.Data, data)
				}

				logger.Log.Info().
					Int("data_segments", len(user.Data)).
					Msg("Formatted user.data segments for OpenRTB")
			}
		}
	}

	// Handle regulations (GDPR/CCPA)
	if maiBid.User != nil {
		regs = &openrtb.Regs{}
		if maiBid.User.GDPRApplies {
			gdpr := 1
			regs.GDPR = &gdpr
		}
		if maiBid.User.USPConsent != "" {
			regs.USPrivacy = maiBid.User.USPConsent
		}
	}

	// Build OpenRTB request
	ortbReq := &openrtb.BidRequest{
		ID:     requestID,
		Imp:    imps,
		Site:   site,
		Device: deviceObj,
		User:   user,
		Regs:   regs,
		Cur:    []string{"USD"},
		TMax:   2500, // 2500ms internal timeout
	}

	return ortbReq, impToSlot, nil
}

// convertToMAIResponse converts OpenRTB response to MAI format
func (h *CatalystBidHandler) convertToMAIResponse(auctionResp *exchange.AuctionResponse, impToSlot map[string]string) *MAIBidResponse {
	maiResp := &MAIBidResponse{
		Bids: []MAIBid{},
	}

	if auctionResp == nil || auctionResp.BidResponse == nil {
		return maiResp
	}

	// Extract all bids from all seats
	for _, seatBid := range auctionResp.BidResponse.SeatBid {
		for _, bid := range seatBid.Bid {
			// Map impression ID back to divID
			divID, ok := impToSlot[bid.ImpID]
			if !ok {
				continue // Skip if we can't map back to slot
			}

			maiBid := MAIBid{
				DivID:      divID,
				CPM:        bid.Price,
				Currency:   auctionResp.BidResponse.Cur,
				Width:      bid.W,
				Height:     bid.H,
				AdID:       bid.ID,
				CreativeID: bid.CRID,
				DealID:     bid.DealID,
			}

			// Set default currency if not specified
			if maiBid.Currency == "" {
				maiBid.Currency = "USD"
			}

			// Build metadata
			if len(bid.ADomain) > 0 || bid.CID != "" {
				maiBid.Meta = &MAIBidMeta{
					AdvertiserDomains: bid.ADomain,
					NetworkID:         bid.CID,
					NetworkName:       seatBid.Seat,
				}
			}

			maiResp.Bids = append(maiResp.Bids, maiBid)
		}
	}

	return maiResp
}

// writeMAIResponse writes MAI-formatted JSON response
func (h *CatalystBidHandler) writeMAIResponse(w http.ResponseWriter, resp *MAIBidResponse) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")

	if err := json.NewEncoder(w).Encode(resp); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to encode MAI response")
	}
}

// writeErrorResponse writes error response
func (h *CatalystBidHandler) writeErrorResponse(w http.ResponseWriter, message string, statusCode int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]string{
		"error": message,
	})
}

// extractBidderParamsFromMapping extracts bidder-specific params from legacy mapping file
// Note: This maintains backward compatibility with integer values in the mapping file
func (h *CatalystBidHandler) extractBidderParamsFromMapping(bidderCode string, adUnitConfig *AdUnitConfig) map[string]interface{} {
	switch bidderCode {
	case "rubicon":
		if adUnitConfig.Rubicon != nil {
			return map[string]interface{}{
				"accountId":        adUnitConfig.Rubicon.AccountID,        // int (correct)
				"siteId":           adUnitConfig.Rubicon.SiteID,           // int (correct)
				"zoneId":           adUnitConfig.Rubicon.ZoneID,           // int (correct)
				"bidonmultiformat": adUnitConfig.Rubicon.BidOnMultiFormat, // bool (correct)
			}
		}
	case "kargo":
		if adUnitConfig.Kargo != nil {
			return map[string]interface{}{
				"placementId": adUnitConfig.Kargo.PlacementID, // string (correct)
			}
		}
	case "sovrn":
		if adUnitConfig.Sovrn != nil {
			// Note: tagid must be string per Prebid Server spec
			return map[string]interface{}{
				"tagid": adUnitConfig.Sovrn.TagID, // string (will be converted from mapping)
			}
		}
	case "pubmatic":
		if adUnitConfig.Pubmatic != nil {
			// Note: publisherId and adSlot must be strings per Prebid Server spec
			return map[string]interface{}{
				"publisherId": adUnitConfig.Pubmatic.PublisherID, // string (will be converted from mapping)
				"adSlot":      adUnitConfig.Pubmatic.AdSlot,      // string (will be converted from mapping)
			}
		}
	case "triplelift":
		if adUnitConfig.Triplelift != nil {
			return map[string]interface{}{
				"inventoryCode": adUnitConfig.Triplelift.InventoryCode, // string (correct)
			}
		}
	}
	return nil
}

// getBidderKeys extracts keys from user IDs map for logging
func getBidderKeys(userIDs map[string]string) []string {
	keys := make([]string, 0, len(userIDs))
	for k := range userIDs {
		keys = append(keys, k)
	}
	return keys
}

// getBidderNames extracts keys from bidder config map for logging
func getBidderNames(impExt map[string]interface{}) []string {
	keys := make([]string, 0, len(impExt))
	for k := range impExt {
		keys = append(keys, k)
	}
	return keys
}


// getConfiguredBidders extracts bidder names from config map for logging
func getConfiguredBidders(configs map[string]map[string]interface{}) []string {
	keys := make([]string, 0, len(configs))
	for k := range configs {
		keys = append(keys, k)
	}
	return keys
}

// detectDeviceType determines device type from User-Agent string
// Returns "mobile" for mobile devices, "desktop" otherwise
func detectDeviceType(userAgent string) string {
	if userAgent == "" {
		return "desktop" // Default to desktop if no UA
	}

	// Normalize to lowercase for case-insensitive matching
	ua := strings.ToLower(userAgent)

	// Mobile device indicators
	mobileIndicators := []string{
		"mobile", "android", "iphone", "ipad", "ipod",
		"blackberry", "windows phone", "webos", "opera mini",
		"opera mobi", "kindle", "silk", "palm", "symbian",
	}

	for _, indicator := range mobileIndicators {
		if strings.Contains(ua, indicator) {
			return "mobile"
		}
	}

	return "desktop"
}
