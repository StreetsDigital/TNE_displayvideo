package endpoints

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/thenexusengine/tne_springwire/internal/exchange"
	"github.com/thenexusengine/tne_springwire/internal/openrtb"
	"github.com/thenexusengine/tne_springwire/internal/storage"
	"github.com/thenexusengine/tne_springwire/internal/usersync"
	"github.com/thenexusengine/tne_springwire/pkg/logger"
)

// BidderMapping represents the full bidder parameter mapping configuration
type BidderMapping struct {
	Publisher struct {
		PublisherID    string   `json:"publisherId"`
		Domain         string   `json:"domain"`
		DefaultBidders []string `json:"defaultBidders"`
	} `json:"publisher"`
	AdUnits map[string]AdUnitConfig `json:"adUnits"`
}

// AdUnitConfig contains bidder-specific parameters for an ad unit
type AdUnitConfig struct {
	Rubicon    *RubiconParams    `json:"rubicon,omitempty"`
	Kargo      *KargoParams      `json:"kargo,omitempty"`
	Sovrn      *SovrnParams      `json:"sovrn,omitempty"`
	Pubmatic   *PubmaticParams   `json:"pubmatic,omitempty"`
	Triplelift *TripleliftParams `json:"triplelift,omitempty"`
}

// RubiconParams are Rubicon/Magnite adapter parameters
type RubiconParams struct {
	AccountID        int  `json:"accountId"`
	SiteID           int  `json:"siteId"`
	ZoneID           int  `json:"zoneId"`
	BidOnMultiFormat bool `json:"bidonmultiformat"`
}

// KargoParams are Kargo adapter parameters
type KargoParams struct {
	PlacementID string `json:"placementId"`
}

// SovrnParams are Sovrn adapter parameters
type SovrnParams struct {
	TagID string `json:"tagid"` // Must be string per Prebid Server spec
}

// PubmaticParams are Pubmatic adapter parameters
type PubmaticParams struct {
	PublisherID string `json:"publisherId"` // Must be string per Prebid Server spec
	AdSlot      string `json:"adSlot"`      // Must be string per Prebid Server spec
}

// TripleliftParams are Triplelift adapter parameters
type TripleliftParams struct {
	InventoryCode string `json:"inventoryCode"`
}

// CatalystBidHandler handles MAI Publisher-compatible bid requests
type CatalystBidHandler struct {
	exchange       *exchange.Exchange
	mapping        *BidderMapping      // Legacy: static mapping file (fallback)
	publisherStore *storage.PublisherStore // Dynamic hierarchical config from database
}

// LoadBidderMapping loads bidder parameter mapping from JSON file
func LoadBidderMapping(path string) (*BidderMapping, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read mapping file: %w", err)
	}

	var mapping BidderMapping
	if err := json.Unmarshal(data, &mapping); err != nil {
		return nil, fmt.Errorf("failed to parse mapping JSON: %w", err)
	}

	logger.Log.Info().
		Int("ad_units", len(mapping.AdUnits)).
		Str("publisher", mapping.Publisher.PublisherID).
		Msg("Loaded bidder mapping")

	return &mapping, nil
}

// NewCatalystBidHandler creates a new Catalyst bid handler
func NewCatalystBidHandler(ex *exchange.Exchange, mapping *BidderMapping, publisherStore *storage.PublisherStore) *CatalystBidHandler {
	return &CatalystBidHandler{
		exchange:       ex,
		mapping:        mapping,
		publisherStore: publisherStore,
	}
}

// MAIBidRequest represents the MAI Publisher bid request format
type MAIBidRequest struct {
	AccountID string       `json:"accountId"`
	Timeout   int          `json:"timeout"` // Client-side timeout in ms
	Slots     []MAISlot    `json:"slots"`
	Page      *MAIPage     `json:"page,omitempty"`
	User      *MAIUser     `json:"user,omitempty"`
	Device    *MAIDevice   `json:"device,omitempty"`
}

// MAISlot represents an ad slot
type MAISlot struct {
	DivID          string      `json:"divId"`
	Sizes          [][]int     `json:"sizes"`
	AdUnitPath     string      `json:"adUnitPath,omitempty"`
	Position       string      `json:"position,omitempty"`
	EnabledBidders []string    `json:"enabled_bidders,omitempty"`
}

// MAIPage represents page context
type MAIPage struct {
	URL        string   `json:"url,omitempty"`
	Domain     string   `json:"domain,omitempty"`
	Keywords   []string `json:"keywords,omitempty"`
	Categories []string `json:"categories,omitempty"`
}

// MAIUser represents user/privacy info
type MAIUser struct {
	ConsentGiven   bool                     `json:"consentGiven,omitempty"`
	ConsentString  string                   `json:"consentString,omitempty"`  // TCFv2 consent string
	GDPRApplies    bool                     `json:"gdprApplies,omitempty"`
	USPConsent     string                   `json:"uspConsent,omitempty"`
	UserIds        map[string]string        `json:"userIds,omitempty"`        // Bidder-specific user IDs from cookie sync
	Data           []map[string]interface{} `json:"data,omitempty"`           // ORTB2 user data segments
	Ext            map[string]interface{}   `json:"ext,omitempty"`            // Additional user extensions
}

// MAIDevice represents device info
type MAIDevice struct {
	Width      int    `json:"width,omitempty"`
	Height     int    `json:"height,omitempty"`
	DeviceType string `json:"deviceType,omitempty"`
	UserAgent  string `json:"userAgent,omitempty"`
}

// MAIBidResponse represents the MAI Publisher bid response format
type MAIBidResponse struct {
	Bids         []MAIBid `json:"bids"`
	ResponseTime int      `json:"responseTime"` // In milliseconds
}

// MAIBid represents a single bid
type MAIBid struct {
	DivID      string      `json:"divId"`
	CPM        float64     `json:"cpm"`
	Currency   string      `json:"currency"`
	Width      int         `json:"width"`
	Height     int         `json:"height"`
	AdID       string      `json:"adId"`
	CreativeID string      `json:"creativeId"`
	DealID     string      `json:"dealId,omitempty"`
	Meta       *MAIBidMeta `json:"meta,omitempty"`
}

// MAIBidMeta represents bid metadata
type MAIBidMeta struct {
	AdvertiserDomains []string `json:"advertiserDomains,omitempty"`
	NetworkID         string   `json:"networkId,omitempty"`
	NetworkName       string   `json:"networkName,omitempty"`
}

// HandleBidRequest handles POST /v1/bid requests
func (h *CatalystBidHandler) HandleBidRequest(w http.ResponseWriter, r *http.Request) {
	log := logger.Log
	startTime := time.Now()

	// CORS is handled by middleware - removed hardcoded wildcard

	// Only accept POST
	if r.Method != "POST" {
		log.Error().
			Str("method", r.Method).
			Str("path", r.URL.Path).
			Msg("Method not allowed - expected POST")
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Parse MAI bid request
	var maiBidReq MAIBidRequest

	// Close body when done
	defer r.Body.Close()

	// Limit request body size to prevent DoS attacks (1MB limit)
	const maxRequestBodySize = 1024 * 1024 // 1MB
	bodyBytes, err := io.ReadAll(io.LimitReader(r.Body, maxRequestBodySize))
	if err != nil {
		log.Error().
			Err(err).
			Str("remote_addr", r.RemoteAddr).
			Str("user_agent", r.Header.Get("User-Agent")).
			Msg("Failed to read MAI bid request body")
		h.writeErrorResponse(w, "Invalid request format", http.StatusBadRequest)
		return
	}

	// DEBUG: Full request dump if enabled
	debugDumpRequests := os.Getenv("DEBUG_DUMP_REQUESTS") == "true"
	if debugDumpRequests {
		log.Debug().
			Str("method", r.Method).
			Str("path", r.URL.Path).
			Str("remote_addr", r.RemoteAddr).
			Str("user_agent", r.Header.Get("User-Agent")).
			Str("content_type", r.Header.Get("Content-Type")).
			Str("request_body", string(bodyBytes)).
			Msg("üîç DEBUG_DUMP_REQUESTS: Full incoming request")
	} else {
		// Log preview for normal debug mode
		requestPreview := string(bodyBytes)
		if len(requestPreview) > 2000 {
			requestPreview = requestPreview[:2000] + "..."
		}
		log.Debug().Str("request_body_preview", requestPreview).Msg("Received MAI bid request")
	}

	if err := json.Unmarshal(bodyBytes, &maiBidReq); err != nil {
		log.Error().
			Err(err).
			Str("request_body", string(bodyBytes)).
			Msg("Failed to parse MAI bid request - invalid JSON")
		h.writeErrorResponse(w, "Invalid request format", http.StatusBadRequest)
		return
	}

	// Validate request
	if err := h.validateMAIBidRequest(&maiBidReq); err != nil {
		log.Error().
			Err(err).
			Str("account_id", maiBidReq.AccountID).
			Int("slots_count", len(maiBidReq.Slots)).
			Interface("request", maiBidReq).
			Msg("‚ùå Invalid MAI bid request - validation failed")
		h.writeErrorResponse(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Convert to OpenRTB
	ortbReq, impToSlot, err := h.convertToOpenRTB(r, &maiBidReq)
	if err != nil {
		log.Error().
			Err(err).
			Str("account_id", maiBidReq.AccountID).
			Int("slots_count", len(maiBidReq.Slots)).
			Msg("‚ùå Failed to convert to OpenRTB")
		h.writeErrorResponse(w, "Internal error", http.StatusInternalServerError)
		return
	}

	// Run auction with 2500ms timeout (MAI Publisher requirement)
	ctx, cancel := context.WithTimeout(r.Context(), 2500*time.Millisecond)
	defer cancel()

	auctionReq := &exchange.AuctionRequest{
		BidRequest: ortbReq,
		Timeout:    2500 * time.Millisecond,
	}

	auctionResp, err := h.exchange.RunAuction(ctx, auctionReq)
	if err != nil {
		log.Error().
			Err(err).
			Str("account_id", maiBidReq.AccountID).
			Int("slots", len(maiBidReq.Slots)).
			Int("timeout_ms", int(time.Since(startTime).Milliseconds())).
			Str("error_type", fmt.Sprintf("%T", err)).
			Msg("‚ùå Auction failed - returning empty bids")
		// Return empty bids on error (MAI Publisher requirement)
		h.writeMAIResponse(w, &MAIBidResponse{
			Bids:         []MAIBid{},
			ResponseTime: int(time.Since(startTime).Milliseconds()),
		})
		return
	}

	// Convert OpenRTB response to MAI format
	maiResp := h.convertToMAIResponse(auctionResp, impToSlot)
	maiResp.ResponseTime = int(time.Since(startTime).Milliseconds())

	// DEBUG: Full response dump if enabled
	debugDumpResponses := os.Getenv("DEBUG_DUMP_RESPONSES") == "true"
	if debugDumpResponses {
		if respJSON, err := json.Marshal(maiResp); err == nil {
			log.Debug().
				Str("response_body", string(respJSON)).
				Int("bids", len(maiResp.Bids)).
				Int("response_time_ms", maiResp.ResponseTime).
				Msg("üîç DEBUG_DUMP_RESPONSES: Full outgoing response")
		}
	} else {
		// Normal debug logging
		log.Debug().
			Int("bids", len(maiResp.Bids)).
			Int("response_time_ms", maiResp.ResponseTime).
			Msg("Catalyst response ready")
	}

	// Write response
	h.writeMAIResponse(w, maiResp)

	log.Info().
		Str("account_id", maiBidReq.AccountID).
		Int("slots", len(maiBidReq.Slots)).
		Int("bids", len(maiResp.Bids)).
		Int("response_time_ms", maiResp.ResponseTime).
		Msg("‚úì Catalyst bid request completed")
}

// validateMAIBidRequest validates the MAI bid request
func (h *CatalystBidHandler) validateMAIBidRequest(req *MAIBidRequest) error {
	if req.AccountID == "" {
		return fmt.Errorf("accountId is required")
	}
	if len(req.Slots) == 0 {
		return fmt.Errorf("at least one slot is required")
	}
	for i, slot := range req.Slots {
		if slot.DivID == "" {
			return fmt.Errorf("slot[%d].divId is required", i)
		}
		if len(slot.Sizes) == 0 {
			return fmt.Errorf("slot[%d].sizes is required", i)
		}
		for j, size := range slot.Sizes {
			if len(size) != 2 || size[0] <= 0 || size[1] <= 0 {
				return fmt.Errorf("slot[%d].sizes[%d] must be [width, height] with positive values", i, j)
			}
		}
	}
	return nil
}

// convertToOpenRTB converts MAI bid request to OpenRTB format
func (h *CatalystBidHandler) convertToOpenRTB(r *http.Request, maiBid *MAIBidRequest) (*openrtb.BidRequest, map[string]string, error) {
	// Generate request ID
	requestID := fmt.Sprintf("catalyst-%d", time.Now().UnixNano())

	// Build impressions and track mapping (impID -> divID)
	imps := make([]openrtb.Imp, 0, len(maiBid.Slots))
	impToSlot := make(map[string]string) // Maps impression ID to slot divID

	for i, slot := range maiBid.Slots {
		impID := fmt.Sprintf("%d", i+1)
		impToSlot[impID] = slot.DivID

		// Convert sizes to format array
		formats := make([]openrtb.Format, len(slot.Sizes))
		for j, size := range slot.Sizes {
			formats[j] = openrtb.Format{
				W: size[0],
				H: size[1],
			}
		}

		imp := openrtb.Imp{
			ID: impID,
			Banner: &openrtb.Banner{
				W:      slot.Sizes[0][0], // Use first size as primary
				H:      slot.Sizes[0][1],
				Format: formats,
			},
			TagID: slot.AdUnitPath,
		}

	// Look up bidder parameters using hierarchical config (DB first, then mapping file fallback)
	// Always try to lookup bidder config, with appropriate fallbacks
	impExt := make(map[string]interface{})

	if maiBid.AccountID == "" {
		logger.Log.Warn().Msg("Missing accountId - cannot lookup bidder config")
	} else {
		// Extract domain from page context
		domain := ""
		if maiBid.Page != nil && maiBid.Page.Domain != "" {
			domain = maiBid.Page.Domain
		}

		// Warn if adUnitPath is missing
		if slot.AdUnitPath == "" {
			logger.Log.Warn().
				Str("publisher", maiBid.AccountID).
				Str("domain", domain).
				Str("div_id", slot.DivID).
				Msg("Missing adUnitPath - falling back to publisher-level config only")
		}

		// List of bidders to look up
		bidders := []string{"rubicon", "kargo", "sovrn", "pubmatic", "triplelift"}

		// OPTIMIZED: Batch lookup all bidder configs in a single database query (was 5x3=15 queries before!)
		var allConfigs map[string]map[string]interface{}
		var err error
		if h.publisherStore != nil {
			allConfigs, err = h.publisherStore.GetAllBidderConfigsHierarchical(
				r.Context(),
				maiBid.AccountID,
				domain,
				slot.AdUnitPath, // May be empty - hierarchical lookup handles this
				bidders,
			)
			if err != nil {
				logger.Log.Error().
					Err(err).
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("ad_unit", slot.AdUnitPath).
					Str("error_type", fmt.Sprintf("%T", err)).
					Str("error_msg", err.Error()).
					Msg("‚ùå Database error looking up bidder configs")
				allConfigs = make(map[string]map[string]interface{})
			} else {
				logger.Log.Info().
					Str("ad_unit", slot.AdUnitPath).
					Strs("bidder_names", getConfiguredBidders(allConfigs)).
					Int("bidders_configured", len(allConfigs)).
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Interface("full_config", allConfigs).
					Msg("‚úì Injected bidder parameters using hierarchical config")
			}
		} else {
			allConfigs = make(map[string]map[string]interface{})
		}

		// Now populate impExt with configs
		for _, bidderCode := range bidders {
			params := allConfigs[bidderCode]

			// If no DB config found, fall back to mapping file (only if we have adUnitPath)
			if params == nil && h.mapping != nil && slot.AdUnitPath != "" {
				if adUnitConfig, ok := h.mapping.AdUnits[slot.AdUnitPath]; ok {
					params = h.extractBidderParamsFromMapping(bidderCode, &adUnitConfig)
				}
			}

			// Add params to impExt if found
			if params != nil && len(params) > 0 {
				impExt[bidderCode] = params
			} else {
				logger.Log.Warn().
					Str("bidder", bidderCode).
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("ad_unit", slot.AdUnitPath).
					Msg("‚ö†Ô∏è  No configuration found for bidder")
			}
		}

		// Marshal and attach to impression
		if len(impExt) > 0 {
			extJSON, err := json.Marshal(impExt)
			if err == nil {
				imp.Ext = extJSON
				logger.Log.Info().
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("ad_unit", slot.AdUnitPath).
					Int("bidders_configured", len(impExt)).
					Interface("bidder_names", getBidderNames(impExt)).
					Interface("full_config", impExt).
					Msg("‚úì Injected bidder parameters using hierarchical config")
			} else {
				logger.Log.Error().
					Err(err).
					Str("publisher", maiBid.AccountID).
					Str("domain", domain).
					Str("ad_unit", slot.AdUnitPath).
					Interface("impExt", impExt).
					Msg("‚ùå Failed to marshal bidder parameters")
			}
		} else {
			logger.Log.Error().
				Str("publisher", maiBid.AccountID).
				Str("domain", domain).
				Str("ad_unit", slot.AdUnitPath).
				Str("div_id", slot.DivID).
				Msg("‚ùå ZERO bidder configuration found - no bids will be returned for this slot!")
		}
	}

		imps = append(imps, imp)
	}

	// Build site
	site := &openrtb.Site{
		ID: maiBid.AccountID,
	}

	if maiBid.Page != nil {
		site.Domain = maiBid.Page.Domain
		if maiBid.Page.URL != "" {
			site.Page = maiBid.Page.URL
		}
		if maiBid.Page.Domain == "" && maiBid.Page.URL != "" {
			// Extract domain from URL if not provided
			site.Domain = extractDomain(maiBid.Page.URL)
		}
		if len(maiBid.Page.Keywords) > 0 {
			site.Keywords = strings.Join(maiBid.Page.Keywords, ",")
		}
		if len(maiBid.Page.Categories) > 0 {
			site.Cat = maiBid.Page.Categories
		}
	}

	// Build device
	device := &openrtb.Device{
		UA: r.Header.Get("User-Agent"),
		IP: getClientIP(r),
	}

	if maiBid.Device != nil {
		if maiBid.Device.UserAgent != "" {
			device.UA = maiBid.Device.UserAgent
		}
		if maiBid.Device.Width > 0 && maiBid.Device.Height > 0 {
			device.W = maiBid.Device.Width
			device.H = maiBid.Device.Height
		}
		// Map device type to OpenRTB device type
		switch strings.ToLower(maiBid.Device.DeviceType) {
		case "mobile", "phone":
			device.DeviceType = 1 // Mobile/Tablet
		case "tablet":
			device.DeviceType = 5 // Tablet
		case "desktop", "pc":
			device.DeviceType = 2 // Personal Computer
		case "tv", "ctv", "connected_tv":
			device.DeviceType = 3 // Connected TV
		}
	}

	// Build user object with IDs from request body AND cookies
	var user *openrtb.User
	var regs *openrtb.Regs

	// Collect user IDs from all sources
	userIDs := make(map[string]string)

	// 1. From request body (SDK sends these)
	if maiBid.User != nil && len(maiBid.User.UserIds) > 0 {
		for bidder, uid := range maiBid.User.UserIds {
			userIDs[bidder] = uid
		}
	}

	// 2. From HTTP cookie as fallback (server-side cookie sync)
	cookieSync := usersync.ParseCookie(r)
	bidders := []string{"rubicon", "kargo", "sovrn", "pubmatic", "triplelift", "appnexus"}
	for _, bidder := range bidders {
		if uid := cookieSync.GetUID(bidder); uid != "" {
			if _, exists := userIDs[bidder]; !exists {
				userIDs[bidder] = uid
			}
		}
	}

	// Create user object if we have IDs or consent data
	if len(userIDs) > 0 || maiBid.User != nil {
		user = &openrtb.User{}

		// MODERN: Store all bidder IDs in user.ext.eids (OpenRTB 2.6+ standard)
		// This provides transparency about ID sources and supports multiple ID types
		if len(userIDs) > 0 {
			eids := make([]map[string]interface{}, 0, len(userIDs))

			// Map bidder codes to proper source domains
			sourceDomains := map[string]string{
				"rubicon":     "rubiconproject.com",
				"kargo":       "kargo.com",
				"sovrn":       "lijit.com",
				"pubmatic":    "pubmatic.com",
				"triplelift":  "3lift.com",
				"appnexus":    "adnxs.com",
			}

			for bidder, uid := range userIDs {
				source := sourceDomains[bidder]
				if source == "" {
					source = bidder + ".com" // Fallback
				}

				eids = append(eids, map[string]interface{}{
					"source": source,
					"uids": []map[string]interface{}{
						{
							"id":    uid,
							"atype": 1, // Browser cookie-based ID
						},
					},
				})
			}

			// Build user.ext with eids and consent
			userExt := map[string]interface{}{
				"eids": eids,
			}

			// Add consent hash if available (GDPR transparency)
			if maiBid.User != nil && maiBid.User.ConsentGiven {
				userExt["consent"] = "1"
			}

			extJSON, _ := json.Marshal(userExt)
			user.Ext = extJSON

			logger.Log.Info().
				Int("user_ids", len(userIDs)).
				Strs("bidders", getBidderKeys(userIDs)).
				Msg("Populated user IDs from cookie sync")
		}

		// Set TCF consent string (OpenRTB 2.5+ compliance)
		if maiBid.User != nil {
			// Use actual TCF string from SDK if available
			if maiBid.User.ConsentString != "" {
				user.Consent = maiBid.User.ConsentString
				log.Debug().
					Str("consent_string_preview", maiBid.User.ConsentString[:min(20, len(maiBid.User.ConsentString))]).
					Msg("Using TCFv2 consent string from SDK")
			} else if maiBid.User.ConsentGiven {
				// Fallback: If no TCF string but consent was given
				log.Warn().
					Str("account_id", maiBid.AccountID).
					Msg("GDPR consent given but no TCF string provided - bidders may reject")
				user.Consent = "1"  // Non-compliant fallback
			} else {
				user.Consent = "0"  // No consent
			}

			// Add ORTB2 user data segments if provided
			if len(maiBid.User.Data) > 0 {
				user.Data = maiBid.User.Data
			}

			// Add user extensions if provided
			if len(maiBid.User.Ext) > 0 {
				user.Ext = maiBid.User.Ext
			}
		}
	}

	// Handle regulations (GDPR/CCPA)
	if maiBid.User != nil {
		regs = &openrtb.Regs{}
		if maiBid.User.GDPRApplies {
			gdpr := 1
			regs.GDPR = &gdpr
		}
		if maiBid.User.USPConsent != "" {
			regs.USPrivacy = maiBid.User.USPConsent
		}
	}

	// Build OpenRTB request
	ortbReq := &openrtb.BidRequest{
		ID:     requestID,
		Imp:    imps,
		Site:   site,
		Device: device,
		User:   user,
		Regs:   regs,
		Cur:    []string{"USD"},
		TMax:   2500, // 2500ms internal timeout
	}

	return ortbReq, impToSlot, nil
}

// convertToMAIResponse converts OpenRTB response to MAI format
func (h *CatalystBidHandler) convertToMAIResponse(auctionResp *exchange.AuctionResponse, impToSlot map[string]string) *MAIBidResponse {
	maiResp := &MAIBidResponse{
		Bids: []MAIBid{},
	}

	if auctionResp == nil || auctionResp.BidResponse == nil {
		return maiResp
	}

	// Extract all bids from all seats
	for _, seatBid := range auctionResp.BidResponse.SeatBid {
		for _, bid := range seatBid.Bid {
			// Map impression ID back to divID
			divID, ok := impToSlot[bid.ImpID]
			if !ok {
				continue // Skip if we can't map back to slot
			}

			maiBid := MAIBid{
				DivID:      divID,
				CPM:        bid.Price,
				Currency:   auctionResp.BidResponse.Cur,
				Width:      bid.W,
				Height:     bid.H,
				AdID:       bid.ID,
				CreativeID: bid.CRID,
				DealID:     bid.DealID,
			}

			// Set default currency if not specified
			if maiBid.Currency == "" {
				maiBid.Currency = "USD"
			}

			// Build metadata
			if len(bid.ADomain) > 0 || bid.CID != "" {
				maiBid.Meta = &MAIBidMeta{
					AdvertiserDomains: bid.ADomain,
					NetworkID:         bid.CID,
					NetworkName:       seatBid.Seat,
				}
			}

			maiResp.Bids = append(maiResp.Bids, maiBid)
		}
	}

	return maiResp
}

// writeMAIResponse writes MAI-formatted JSON response
func (h *CatalystBidHandler) writeMAIResponse(w http.ResponseWriter, resp *MAIBidResponse) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")

	if err := json.NewEncoder(w).Encode(resp); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to encode MAI response")
	}
}

// writeErrorResponse writes error response
func (h *CatalystBidHandler) writeErrorResponse(w http.ResponseWriter, message string, statusCode int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]string{
		"error": message,
	})
}

// extractBidderParamsFromMapping extracts bidder-specific params from legacy mapping file
// Note: This maintains backward compatibility with integer values in the mapping file
func (h *CatalystBidHandler) extractBidderParamsFromMapping(bidderCode string, adUnitConfig *AdUnitConfig) map[string]interface{} {
	switch bidderCode {
	case "rubicon":
		if adUnitConfig.Rubicon != nil {
			return map[string]interface{}{
				"accountId":        adUnitConfig.Rubicon.AccountID,        // int (correct)
				"siteId":           adUnitConfig.Rubicon.SiteID,           // int (correct)
				"zoneId":           adUnitConfig.Rubicon.ZoneID,           // int (correct)
				"bidonmultiformat": adUnitConfig.Rubicon.BidOnMultiFormat, // bool (correct)
			}
		}
	case "kargo":
		if adUnitConfig.Kargo != nil {
			return map[string]interface{}{
				"placementId": adUnitConfig.Kargo.PlacementID, // string (correct)
			}
		}
	case "sovrn":
		if adUnitConfig.Sovrn != nil {
			// Note: tagid must be string per Prebid Server spec
			return map[string]interface{}{
				"tagid": adUnitConfig.Sovrn.TagID, // string (will be converted from mapping)
			}
		}
	case "pubmatic":
		if adUnitConfig.Pubmatic != nil {
			// Note: publisherId and adSlot must be strings per Prebid Server spec
			return map[string]interface{}{
				"publisherId": adUnitConfig.Pubmatic.PublisherID, // string (will be converted from mapping)
				"adSlot":      adUnitConfig.Pubmatic.AdSlot,      // string (will be converted from mapping)
			}
		}
	case "triplelift":
		if adUnitConfig.Triplelift != nil {
			return map[string]interface{}{
				"inventoryCode": adUnitConfig.Triplelift.InventoryCode, // string (correct)
			}
		}
	}
	return nil
}

// getBidderKeys extracts keys from user IDs map for logging
func getBidderKeys(userIDs map[string]string) []string {
	keys := make([]string, 0, len(userIDs))
	for k := range userIDs {
		keys = append(keys, k)
	}
	return keys
}

// getBidderNames extracts keys from bidder config map for logging
func getBidderNames(impExt map[string]interface{}) []string {
	keys := make([]string, 0, len(impExt))
	for k := range impExt {
		keys = append(keys, k)
	}
	return keys
}

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// getConfiguredBidders extracts bidder names from config map for logging
func getConfiguredBidders(configs map[string]map[string]interface{}) []string {
	keys := make([]string, 0, len(configs))
	for k := range configs {
		keys = append(keys, k)
	}
	return keys
}
